from sage.all import Ideal, SR, PolynomialRing, Set
from sage.all import prod, XGCD as xgcd, jacobian

from copy import copy

from sage_acsv.helpers import rational_function_reduce

def get_nullstellensatz_certificate(R, Hs, multiplicities):
    r"""Finds a Nullstellensatz ceritificate of a set of polynomials, or
    None if one doesn't exist.

    A Nullstellensatz ceritificate exists for any set of polynomials `H_1,\dots,H_s`
    with no common zeroes. Equivalently, `1` is in the ideal generated by `H_1,\dots,H_s`.
    It is a list of polynomials `p_1,\dots,p_s` such that `p_1H_1 + \dots + p_sH_s = 1`.

    INPUT:
    * ``R`` -- A `PolynomialRing`.
    * ``Hs`` -- A list of square-free polynomials in `R`.
    * ``multiplicities`` -- A list of integers representing powers of `Hs`.

    OUTPUT:

    A list of polynomials in `R`.
    
    EXAMPLES::

        sage: from sage_acsv.decomposition import get_nullstellensatz_certificate
        sage: R.<x,y> = PolynomialRing(QQ, 2)
        sage: get_nullstellensatz_certificate(R, [1-x,1-y,1-x-y], [1,1,2])
        [x + 1, 2*x + y - 1, 1]
    """
    Id = Ideal([H**m for H,m in zip(Hs, multiplicities)])
    if R.one() in Id:
        return R.one().lift(Id)
    return None

def compute_nullstellensatz_decomposition(R, G, H):
    r"""Computes a Nullstellensatz decomposition of the rational function `G/H`.

    A Nullstellensatz decomposition for `G/H` is a sum of rational functions of the form
    `G/H = \sum_{k}\frac{p_k}{q_{k_1}^{e_{k_1}}\dots q_{k_i}^{e_{k_i}}` such that 
    `q_{k_1}, ..., q_{k_i}` are factors of `H` that do not generate the ideal `R`.

    INPUT:
    * ``R`` -- A `PolynomialRing`.
    * ``G, H`` -- Polynomials representing the rational function `G/H`.

    OUTPUT:

    A list of tuples `(G_i,H_i)` where `G_i, H_i` are in `R`.
    
    EXAMPLES::

        sage: from sage_acsv.decomposition import compute_nullstellensatz_decomposition
        sage: R.<x,y> = PolynomialRing(QQ, 2)
        sage: compute_nullstellensatz_decomposition(R, 1, x*y*(x+1))
        [(-1, x*y + y), (1, x*y)]
    """
    G,H = rational_function_reduce(G,H)
    G /= H.factor().unit()

    if len(H.factor()) == 0:
        return [(G,H)]

    Hs, multiplicities = zip(*list(H.factor()))
    cert = get_nullstellensatz_certificate(R, Hs, multiplicities)
    if cert is None:
        return [(G, H)]

    decomp = []
    m = len(Hs)
    partial_decomp = [
        (G*cert[i], prod([Hs[j]**multiplicities[j] for j in range(m) if j != i]))
        for i in range(m)
    ]

    for num, denom in partial_decomp:
        decomp.extend(compute_nullstellensatz_decomposition(R, num, denom))

    decomp = [term for term in decomp if term[0] != 0]
    return decomp # todo: combine parts
    
def get_algebraic_independence_ceritificate(R, Hs, multiplicities):
    r"""Finds an algebraic independence certificate of a set `Hs` of polynomials.

    An algebraic independence ceritificate is an annhilating polynomial of `Hs` over
    the same base ring.

    INPUT:
    * ``R`` -- A `PolynomialRing`.
    * ``Hs`` -- A list of square-free polynomials in `R`.
    * ``multiplicities`` -- A list of integers representing powers of `Hs`.

    OUTPUT:

    A list of polynomials in variables `T_1,...,T_m` over the same base ring as `R`,
    where `m` is the length of `Hs`.
    
    EXAMPLES::

        sage: from sage_acsv.decomposition import get_algebraic_independence_ceritificate
        sage: R.<x,y> = PolynomialRing(QQ, 2)
        sage: get_algebraic_independence_ceritificate(R, [x, x*y+1,y], [2,1,3])
        Ideal (1 - 6*T1 + 15*T1^2 - 20*T1^3 + 15*T1^4 - T0^3*T2^2 - 6*T1^5 + T1^6) of Multivariate Polynomial Ring in T0, T1, T2 over Rational Field
    """

    if not Hs:
        return R.ideal()
    m = len(Hs)
    F = R.base_ring()
    vs = list(R.gens())
    d = len(vs)

    # Expand R by 2m variables
    Ss = list(SR.var('S', m))
    Ts = list(SR.var('T', m))
    R_ext = PolynomialRing(F, vs + Ss + Ts)
    vs = R_ext.gens()[:d]
    Ss = R_ext.gens()[d:d+m]
    Ts = R_ext.gens()[d+m:]

    J = R_ext.ideal(
        [Ss[j] - R_ext(Hs[j]) for j in range(m)] + 
        [Ss[j] ** multiplicities[j] - Ts[j] for j in range(m)
    ])
    J = J.elimination_ideal(vs + Ss)

    R_T = PolynomialRing(F, [str(T) for T in Ts], order='negdeglex')
    return R_T.ideal(J)
    
def compute_algebraic_dependence_decomposition(R, G, H):
    r"""Computes an algebraic dependence decomposition of the rational function `G/H`.

    An algebraic dependence decomposition for `G/H` is a sum of rational functions of the 
    form `G/H = \sum_{k}\frac{p_k}{q_{k_1}^{e_{k_1}}\dots q_{k_i}^{e_{k_i}}` such that 
    `q_{k_1},\dots,q_{k_i}` are algebraically independent factors of `H`.

    INPUT:
    * ``R`` -- A `PolynomialRing`.
    * ``G, H`` -- Polynomials representing the rational function `G/H`.

    OUTPUT:

    A list of tuples `(G_i,H_i)` where `G_i, H_i` are in `R`.
    
    EXAMPLES::

        sage: from sage_acsv.decomposition import compute_nullstellensatz_decomposition
        sage: R.<x,y> = PolynomialRing(QQ, 2)
        sage: compute_nullstellensatz_decomposition(R, 1, x^2*(x*y+1)*y)
        [(2, x^2*y), (-x*y - 1, x^2*y), (y, x*y + 1)]
    """
    G,H = rational_function_reduce(G,H)
    G /= H.factor().unit()

    if len(H.factor()) == 0:
        return [(G,H)]

    Hs, multiplicities = zip(*list(H.factor()))

    J = get_algebraic_independence_ceritificate(R, Hs, multiplicities)
    #print(J)
    if not J:
        return [(G, H)]

    decomp = []
    m = len(Hs)
    g = J.gens()[0] # annhilating poly of Hs**multiplicities
    Ts = J.ring().gens()
    gg = (g.lt()-g)/(g.lc())
    T_nums = [c*f for c, f in zip(gg.coefficients(), gg.monomials())]
    e = list(g.lt().exponents())[:m]
    T_denoms = [Ts[j] for j in range(m)]
    T_mults = [e[0][j]+1 for j in range(m)]

    T_decomp = [(T_num, T_denoms, T_mults) for T_num in T_nums]
    subs_dict = {Ts[j]: Hs[j]**multiplicities[j] for j in range(m)}
    for T_num, T_denoms, T_mults in T_decomp:
        num = G * (J.ring()(T_num)).subs(subs_dict)
        denom = 1
        for T_denom, T_mult in zip(T_denoms, T_mults):
            j = Ts.index(T_denom)
            denom *= Hs[j]**(multiplicities[j]*T_mult)

        decomp.extend(compute_algebraic_dependence_decomposition(R, num, denom))

    return decomp

def compute_leinartas_decomposition(R, G, H):
    r"""Computes a Leinartas decomposition of the rational function `G/H`.

    An Leinartas decomposition for `G/H` is a sum of rational functions of the 
    form `G/H = \sum_{k}\frac{p_k}{q_{k_1}^{e_{k_1}}\dots q_{k_i}^{e_{k_i}}` such that 
    `q_{k_1},\dots,q_{k_i}` are algebraically independent factors of `H`  that do not
    generate the ideal `R`.

    INPUT:
    * ``R`` -- A `PolynomialRing`.
    * ``G, H`` -- Polynomials representing the rational function `G/H`.

    OUTPUT:

    A list of tuples `(G_i,H_i)` where `G_i, H_i` are in `R`.
    
    EXAMPLES::

        sage: from sage_acsv.decomposition import compute_leinartas_decomposition
        sage: R.<x,y,z> = PolynomialRing(QQ, 3)
        sage: compute_leinartas_decomposition(R, 1, (x*y*z*(x*y+z)))
        [(1, x*y*z^2), (-1, x*y*z^2 + z^3)]
    """
    if len(R.gens()) == 1:
        return # just do partial fraction here

    null_decomp = compute_nullstellensatz_decomposition(R, G, H)
    decomp = []
    for num, denom in null_decomp:
        decomp.extend(compute_algebraic_dependence_decomposition(R, num, denom)) 

    return decomp

def compute_cohomology_decomposition(R, G, H):
    r"""Computes a cohomology decomposition of the rational function `G/H`.

    Given a a rational function `G/H`, a cohomology decomposition is a rational
    function `G'/H'` over the same ring that is de Rham cohomologous to `G/H` and whose
    denominator contains no repeated factor.

    INPUT:
    * ``R`` -- A `PolynomialRing`.
    * ``G, H`` -- Polynomials representing the rational function `G/H`.

    OUTPUT:

    A tuple `(G',H')` where `G_i, H_i` are in `R` and `H'` is square-free
    
    EXAMPLES::

        sage: from sage_acsv.decomposition import compute_cohomology_decomposition
        sage: R.<x,y> = PolynomialRing(QQ, 2)
        sage: cohomology_decomposition(R, 1, (x*y-1)*(x^2+y^2-1)^2)
        (-4/3*x^2*y^2 + 4/3*x*y + 1/3, x^3*y + x*y^3 - x^2 - x*y - y^2 + 1)
    """
    G,H = rational_function_reduce(G,H)
    if len(H.factor()) == 0:
        return G,H

    Hs, multiplicities = zip(*list(H.factor()))
    Hs, multiplicities = list(Hs), list(multiplicities)
    n = len(Hs)
    if sum(multiplicities) <= n:
        # No decomposing possible.
        return G, H

    # Otherwise decompose recursively.
    decomp_terms = []
    # sort according to the term order of R
    vs = sorted(R.gens())
    var_sets_n = sorted(sorted(s) for s in Set(vs).subsets(n))

    # Compute Jacobian determinants for Hs.
    dets = [R(jacobian(Hs, v).determinant())
            for v in var_sets_n]

    # Get a Nullstellensatz certificate for Hs and dets.
    if len(vs) == 1:
        # Use xgcd() in univariate case
        L = xgcd(Hs[0], dets[0])[1:]
    else:
        L = R.one().lift(R.ideal(Hs + dets))

    # Do first iteration of decomposition.
    tmp_terms = []
    # Contributions from Hs.
    for i in range(n):
        if L[i] == 0:
            continue
        # Cancel one exponent from denominator.
        tmp_Hs = copy(Hs)
        tmp_multiplicities = copy(multiplicities)
        if tmp_multiplicities[i] > 1:
            tmp_multiplicities[i] -= 1
        else:
            tmp_Hs.pop(i)
            tmp_multiplicities.pop(i)
        tmp_terms.append((G * L[i], tmp_Hs, tmp_multiplicities))

    # Contributions from dets.
    # Compute each contribution's cohomologous form using
    # the least index j such that multiplicities[j] > 1.
    # Know such an index exists by first 'if' statement at
    # the top.
    for j in range(n):
        if multiplicities[j] > 1:
            idx_J = j
            break
    new_Hs = copy(Hs)
    new_multiplicities = copy(multiplicities)
    new_multiplicities[idx_J] -= 1
    for k, x in enumerate(var_sets_n):
        if L[n + k] == 0:
            continue
        # Compute Jacobian in the Symbolic Ring.
        jac = jacobian([SR(G * L[n + k])] +
                       [SR(Hs[j]) for j in range(n) if j != idx_J],
                       [SR(xx) for xx in x])
        det = jac.determinant()
        tmp_terms.append(((-1) ** idx_J * det / new_multiplicities[idx_J], new_Hs, new_multiplicities))

    # Now decompose each term
    for num, denom, mults in tmp_terms:
        denom = prod([denom[i] ** mults[i] for i in range(len(denom))])
        decomp_terms.append(compute_cohomology_decomposition(R, R(num), R(denom)))

    new_F = sum([new_G/new_H for new_G, new_H in decomp_terms])
    return new_F.numerator(), new_F.denominator()